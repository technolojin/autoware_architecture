# Copyright 2025 TIER IV, inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import re
import sys

import yaml


def pascal_to_snake(name: str) -> str:
    """Convert PascalCase to snake_case."""
    s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
    return re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).lower()


def check_module_configuration(module_yaml) -> bool:
    #
    return True


def create_module_launcher_xml(module_yaml, executable_name: str) -> str:

    # Extract necessary information from the module YAML
    launch_config = module_yaml.get("launch")
    package_name = launch_config.get("package")
    plugin_name = launch_config.get("plugin")
    node_output = launch_config.get("node_output", "screen")
    use_container = launch_config.get("use_container", False)
    if use_container and not launch_config.get("container_name"):
        ValueError("Container name is required when use_container is True")
        return
    container_name = launch_config.get("container_name")

    # Extract interface information
    input_list = module_yaml.get("inputs")
    output_list = module_yaml.get("outputs")

    # Extract parameter information
    param_path_list = module_yaml.get("parameters")

    # Extract configuration information
    configuration_list = module_yaml.get("configurations")

    # node name is snake case of the module name which the original is in pascal case
    # e.g. ObjectDetector.module -> object_detector
    node_name = module_yaml.get("name").split(".")[0]
    node_name = pascal_to_snake(node_name)

    # Generate the XML content
    lines = []

    # 1. header
    lines.append('<?xml version="1.0"?>')
    lines.append("<!-- This file is auto-generated by the perception architecture -->")
    lines.append("<launch>")
    lines.append(f'  <arg name="node_name" default="{node_name}"/>')

    # 2. Interface
    lines.append("  <!-- Interface -->")
    for if_input in input_list:
        input_name = if_input.get("name")
        lines.append(f'  <arg name="input/{input_name}" default="{input_name}"/>')
    for if_output in output_list:
        output_name = if_output.get("name")
        lines.append(f'  <arg name="output/{output_name}" default="{output_name}"/>')

    # 3. Parameter file paths
    lines.append("  <!-- Parameter file paths -->")
    for param_path in param_path_list:
        lines.append(
            f'  <arg name="{param_path.get("name")}" default="{param_path.get("default")}"/>'
        )

    # 4. Configuration
    lines.append("  <!-- Configuration -->")
    for configuration in configuration_list:
        default_value = (
            str(configuration.get("default")).lower()
            if configuration.get("type") == "bool"
            else configuration.get("default")
        )
        lines.append(f'  <arg name="{configuration.get("name")}" default="{default_value}"/>')
    # 5. Node
    indent = "    "
    lines.append("")
    if use_container:
        lines.append(f'  <load_composable_node target="{container_name}">')
        lines.append(
            f'    <composable_node pkg="{package_name}" plugin="{plugin_name}" name="${{node_name}}">'
        )
        indent = "      "
    else:
        lines.append(
            f'  <node pkg="{package_name}" exec="{executable_name}" name="${{node_name}}" output="{node_output}">'
        )

    # remap the input and output topics
    lines.append(f"{indent}<!-- Remap input and output topics -->")
    for if_input in input_list:
        input_name = if_input.get("name")
        lines.append(f'{indent}<remap from="~/input/{input_name}" to="$(var input/{input_name})"/>')
    for if_output in output_list:
        output_name = if_output.get("name")
        lines.append(
            f'{indent}<remap from="~/output/{output_name}" to="$(var output/{output_name})"/>'
        )
    # add parameters
    lines.append(f"{indent}<!-- Parameters -->")
    for param_path in param_path_list:
        allow_substs = str(param_path.get("allow_substs", "false")).lower()
        lines.append(
            f'{indent}<param from="$(var {param_path.get("name")})" allow_substs="{allow_substs}"/>'
        )

    # add configurations
    lines.append(f"{indent}<!-- Configurations -->")
    for configuration in configuration_list:
        lines.append(
            f'{indent}<param name="{configuration.get("name")}" value="$(var {configuration.get("name")})"/>'
        )

    # close
    if use_container:
        lines.append("    </composable_node>")
        lines.append("  </load_composable_node>")
    else:
        lines.append("  </node>")
    lines.append("</launch>")

    # Join all lines to form the final XML content
    launcher = "\n".join(lines)
    return launcher


def generate_launcher(module_yaml_dir, executable_name, launch_file_dir) -> None:
    # parse the architecture yaml configuration
    with open(module_yaml_dir, "r") as stream:
        try:
            module_yaml = yaml.safe_load(stream)
        except yaml.YAMLError as exc:
            print(exc)
            return
    if "name" not in module_yaml:
        ValueError(f"Field 'name' is required in module configuration., {module_yaml_dir}")
        return
    module_name = module_yaml.get("name")

    # check the module configuration
    # if the configuration is not correct, warn the user
    if not check_module_configuration(module_yaml):
        print(f"Invalid module configuration: {launch_file_dir}")
        return

    # generate xml launcher file
    launcher_xml = create_module_launcher_xml(module_yaml, executable_name)

    # generate the launch file
    launch_file = f"{module_name}.launch.xml"
    launch_file_path = os.path.join(launch_file_dir, launch_file)

    # if the directory does not exist, create the directory
    os.makedirs(os.path.dirname(launch_file_path), exist_ok=True)

    # if file exists, remove the file
    if os.path.exists(launch_file_path):
        os.remove(launch_file_path)

    # save the launch file to the launch file directory
    with open(launch_file_path, "w") as f:
        # save empty file at this moment
        f.write(launcher_xml)


if __name__ == "__main__":
    generate_launcher(sys.argv[1], sys.argv[2], sys.argv[3])
