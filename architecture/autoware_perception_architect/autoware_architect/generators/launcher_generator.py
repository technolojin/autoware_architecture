# Copyright 2025 TIER IV, inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Launcher generator for creating ROS 2 launch files."""

import os
import logging
from pathlib import Path
from typing import Dict, Any, List, Union, Optional
from jinja2 import Environment, FileSystemLoader, Template

from ..models.elements import ModuleElement
from ..utils.naming import pascal_to_snake
from ..config import config
from ..exceptions import ValidationError

logger = logging.getLogger(__name__)


class LauncherGenerator:
    """Generates ROS 2 launch XML files for modules."""
    
    def __init__(self, template_dir: Optional[Path] = None):
        """Initialize launcher generator.
        
        Args:
            template_dir: Directory containing Jinja2 templates. If None, uses built-in templates.
        """
        self.template_dir = template_dir or config.template_dir
        
        if self.template_dir and self.template_dir.exists():
            self.env = Environment(loader=FileSystemLoader(self.template_dir))
            logger.debug(f"Using template directory: {self.template_dir}")
        else:
            # Use built-in templates
            self.env = None
            logger.debug("Using built-in templates")
    
    def generate_module_launcher(
        self, 
        module: ModuleElement, 
        executable_name: str,
        output_dir: Union[str, Path]
    ) -> Path:
        """Generate launcher file for a module.
        
        Args:
            module: Module element to generate launcher for
            executable_name: Name of the executable
            output_dir: Directory to save launcher file
            
        Returns:
            Path to generated launcher file
            
        Raises:
            ValidationError: If generation fails
        """
        try:
            # Generate XML content
            if self.env:
                xml_content = self._generate_from_template(module, executable_name)
            else:
                xml_content = self._generate_builtin_xml(module, executable_name)
            
            # Create output path
            output_path = Path(output_dir)
            launch_file_name = f"{module.full_name}.launch.xml"
            launch_file_path = output_path / launch_file_name
            
            # Ensure output directory exists
            launch_file_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Write launcher file
            with open(launch_file_path, 'w', encoding='utf-8') as f:
                f.write(xml_content)
            
            logger.info(f"Generated launcher file: {launch_file_path}")
            return launch_file_path
            
        except Exception as exc:
            raise ValidationError(f"Failed to generate launcher for {module.full_name}: {exc}")
    
    def _generate_from_template(self, module: ModuleElement, executable_name: str) -> str:
        """Generate XML content using Jinja2 template.
        
        Args:
            module: Module element
            executable_name: Executable name
            
        Returns:
            Generated XML content
        """
        template = self.env.get_template('module_launcher.xml.j2')
        
        # Prepare template context
        context = self._prepare_template_context(module, executable_name)
        
        return template.render(**context)
    
    def _generate_builtin_xml(self, module: ModuleElement, executable_name: str) -> str:
        """Generate XML content using built-in template.
        
        Args:
            module: Module element
            executable_name: Executable name
            
        Returns:
            Generated XML content
        """
        # Prepare context
        context = self._prepare_template_context(module, executable_name)
        
        # Generate XML using string formatting
        lines = []
        
        # Header
        lines.append('<?xml version="1.0"?>')
        lines.append("<!-- This file is auto-generated by the perception architecture -->")
        lines.append("<launch>")
        lines.append(f'  <arg name="node_name" default="{context["node_name"]}"/>')
        
        # Interface arguments
        lines.append("  <!-- Interface -->")
        for input_item in context["inputs"]:
            input_name = input_item["name"]
            lines.append(f'  <arg name="input/{input_name}" default="{input_name}"/>')
        
        for output_item in context["outputs"]:
            output_name = output_item["name"]
            lines.append(f'  <arg name="output/{output_name}" default="{output_name}"/>')
        
        # Parameter file paths
        lines.append("  <!-- Parameter file paths -->")
        for param_path in context["parameters"]:
            param_name = param_path.get("name", "")
            param_default = param_path.get("default", "")
            lines.append(f'  <arg name="{param_name}" default="{param_default}"/>')
        
        # Configuration arguments
        lines.append("  <!-- Configuration -->")
        for configuration in context["configurations"]:
            config_name = configuration.get("name", "")
            config_default = configuration.get("default", "")
            if configuration.get("type") == "bool":
                config_default = str(config_default).lower()
            lines.append(f'  <arg name="{config_name}" default="{config_default}"/>')
        
        # Node definition
        lines.append("")
        indent = "    "
        
        if context["use_container"]:
            container_name = context["container_name"]
            plugin_name = context["plugin_name"]
            package_name = context["package_name"]
            
            lines.append(f'  <load_composable_node target="{container_name}">')
            lines.append(f'    <composable_node pkg="{package_name}" plugin="{plugin_name}" name="${{node_name}}">')
            indent = "      "
        else:
            package_name = context["package_name"]
            node_output = context["node_output"]
            
            lines.append(f'  <node pkg="{package_name}" exec="{executable_name}" name="${{node_name}}" output="{node_output}">')
        
        # Topic remapping
        lines.append(f"{indent}<!-- Remap input and output topics -->")
        for input_item in context["inputs"]:
            input_name = input_item["name"]
            lines.append(f'{indent}<remap from="~/input/{input_name}" to="$(var input/{input_name})"/>')
        
        for output_item in context["outputs"]:
            output_name = output_item["name"]
            lines.append(f'{indent}<remap from="~/output/{output_name}" to="$(var output/{output_name})"/>')
        
        # Parameters
        lines.append(f"{indent}<!-- Parameters -->")
        for param_path in context["parameters"]:
            param_name = param_path.get("name", "")
            allow_substs = str(param_path.get("allow_substs", "false")).lower()
            lines.append(f'{indent}<param from="$(var {param_name})" allow_substs="{allow_substs}"/>')
        
        # Configurations
        lines.append(f"{indent}<!-- Configurations -->")
        for configuration in context["configurations"]:
            config_name = configuration.get("name", "")
            lines.append(f'{indent}<param name="{config_name}" value="$(var {config_name})"/>')
        
        # Close node
        if context["use_container"]:
            lines.append("    </composable_node>")
            lines.append("  </load_composable_node>")
        else:
            lines.append("  </node>")
        
        lines.append("</launch>")
        
        return "\n".join(lines)
    
    def _prepare_template_context(self, module: ModuleElement, executable_name: str) -> Dict[str, Any]:
        """Prepare template context for rendering.
        
        Args:
            module: Module element
            executable_name: Executable name
            
        Returns:
            Template context dictionary
        """
        # Convert module name to snake_case for node name
        node_name = pascal_to_snake(module.name)
        
        # Validate container configuration
        if module.use_container and not module.container_name:
            raise ValidationError("Container name is required when use_container is True")
        
        return {
            "module_name": module.name,
            "full_name": module.full_name,
            "node_name": node_name,
            "package_name": module.package_name,
            "plugin_name": module.plugin_name,
            "executable_name": executable_name,
            "node_output": module.node_output,
            "use_container": module.use_container,
            "container_name": module.container_name,
            "inputs": module.inputs,
            "outputs": module.outputs,
            "parameters": module.parameters,
            "configurations": module.configurations,
        }
    
    def generate_batch_launchers(
        self,
        modules: List[ModuleElement],
        executable_name: str,
        output_dir: Union[str, Path]
    ) -> List[Path]:
        """Generate launcher files for multiple modules.
        
        Args:
            modules: List of module elements
            executable_name: Name of the executable
            output_dir: Directory to save launcher files
            
        Returns:
            List of paths to generated launcher files
        """
        generated_files = []
        
        for module in modules:
            try:
                launcher_path = self.generate_module_launcher(module, executable_name, output_dir)
                generated_files.append(launcher_path)
            except Exception as exc:
                logger.error(f"Failed to generate launcher for {module.full_name}: {exc}")
                # Continue with other modules
        
        logger.info(f"Generated {len(generated_files)} launcher files")
        return generated_files


# Global launcher generator instance
launcher_generator = LauncherGenerator()
