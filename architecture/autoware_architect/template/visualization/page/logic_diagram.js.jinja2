// Logic Diagram Module
// This module provides functionality to render logic diagrams using Viz.js (Graphviz)

class LogicDiagramModule {
    constructor(container, options = {}) {
        this.container = container;
        this.options = {
            mode: options.mode || 'default',
            deployment: options.deployment || '',
            ...options
        };

        this.panZoomInstance = null;
        this.init();
    }

    async init() {
        try {
            // Load required libraries if not already loaded
            if (!this.isGraphvizLoaded()) {
                console.log('Loading viz.js...');
                // Initialize Viz object for viz.js to attach to
                if (!window.Viz) {
                    window.Viz = {};
                }
                await this.loadScript('https://cdn.jsdelivr.net/npm/viz.js@2.1.2/full.render.js');
                console.log('viz.js loaded, graphviz available:', this.isGraphvizLoaded());
            }

            // Wait for graphviz to be fully ready
            await this.waitForGraphvizReady();

            if (typeof svgPanZoom === 'undefined') {
                console.log('Loading svg-pan-zoom...');
                await this.loadScript('https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js');
                console.log('svg-pan-zoom loaded');
            }

            // Add interaction styles early
            this.addInteractionStyles();

            // Load and render the diagram
            await this.loadAndRender();
        } catch (error) {
            console.error('Error in init:', error);
            throw error;
        }
    }

    isGraphvizLoaded() {
        return typeof window !== 'undefined' && window.Viz && typeof window.Viz.render === 'function';
    }

    async waitForGraphvizReady() {
        return new Promise((resolve) => {
            const checkReady = () => {
                if (this.isGraphvizLoaded()) {
                    resolve();
                } else {
                    setTimeout(checkReady, 50);
                }
            };
            checkReady();
        });
    }

    addInteractionStyles() {
        // Add CSS for interactions
        const styleId = 'logic-diagram-interaction-styles';
        if (!document.getElementById(styleId)) {
            const style = document.createElement('style');
            style.id = styleId;
            style.textContent = `
                .logic-diagram-container svg {
                    cursor: grab;
                }
                .logic-diagram-container svg:active {
                    cursor: grabbing;
                }
                .logic-diagram-node:hover {
                    stroke: #007bff !important;
                    stroke-width: 2px !important;
                }
                .logic-diagram-edge:hover {
                    stroke: #007bff !important;
                    stroke-width: 2px !important;
                }
                .logic-diagram-cluster:hover {
                    stroke: #007bff !important;
                    stroke-width: 2px !important;
                }
                .highlighted {
                    stroke: #dc3545 !important;
                    stroke-width: 3px !important;
                    fill: #fff3cd !important;
                }
            `;
            document.head.appendChild(style);
        }
    }

    async loadScript(src) {
        return new Promise((resolve, reject) => {
            // Check if script is already loaded
            const existingScript = document.querySelector(`script[src="${src}"]`);
            if (existingScript) {
                resolve();
                return;
            }

            const script = document.createElement('script');
            script.src = src;
            script.onload = () => resolve();
            script.onerror = (event) => {
                const error = new Error(`Failed to load script: ${src}`);
                error.event = event;
                reject(error);
            };
            document.head.appendChild(script);
        });
    }

    async loadDataScript(mode) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = `data/${mode}_logic_diagram.js`;
            script.onload = () => resolve();
            script.onerror = (error) => reject(error);
            document.head.appendChild(script);
        });
    }

    async loadAndRender() {
        try {
            // Load data if not already loaded
            if (!window.logicDiagramData || !window.logicDiagramData[this.options.mode]) {
                await this.loadDataScript(this.options.mode);
            }

            if (!window.logicDiagramData || !window.logicDiagramData[this.options.mode]) {
                throw new Error(`No logic diagram data available for mode: ${this.options.mode}`);
            }

            // Generate DOT syntax from data and render
            const data = window.logicDiagramData[this.options.mode];
            const dotSyntax = this.generateDotSyntax(data);
            await this.renderLogicDiagram(dotSyntax);

        } catch (error) {
            console.error('Error loading logic diagram:', error);
            this.showError(`Error loading logic diagram: ${error.message}`);
        }
    }

    generateDotSyntax(root) {
        let dotLines = [];

        // Graph header
        dotLines.push(`digraph logic_diagram {`);
        dotLines.push(`\tlabel="System Diagram ${root.name}";`);
        dotLines.push(`\tlabelloc=top;`);
        dotLines.push(`\tfontsize=20;`);
        dotLines.push(`\tfontname="Arial";`);
        dotLines.push(`\trankdir=LR;`);
        dotLines.push(`\tnode [shape=box, style=filled, fillcolor="#dddddd", fontname="Arial", fontsize=10];`);
        dotLines.push(`\tedge [fontname="Arial", fontsize=8, color="#000066"];`);
        dotLines.push(``);

        // Build instance graphs recursively
        this.buildInstanceGraph(root, dotLines);

        dotLines.push(`}`);
        return dotLines.join('\n');
    }

    buildInstanceGraph(instance, dotLines) {
        if (instance.entity_type === "node") {
            // Node cluster
            dotLines.push(`\tsubgraph cluster_${instance.unique_id} {`);
            dotLines.push(`\t\tlabel="${instance.name}";`);
            if (instance.vis_guide) {
                dotLines.push(`\t\tstyle="rounded,filled"; color="${instance.vis_guide.color}"; fillcolor="${instance.vis_guide.background_color}"; fontcolor="${instance.vis_guide.text_color}";`);
            }
            dotLines.push(`\t\tnode [style=filled, fillcolor=white];`);

            // Input ports
            if (instance.in_ports && Array.isArray(instance.in_ports)) {
                instance.in_ports.forEach(port => {
                    if (port && port.unique_id && port.name) {
                        const eventType = port.event ? port.event.type : 'unknown';
                        const eventFreq = port.event && port.event.frequency !== null ? port.event.frequency : 'unknown';
                        dotLines.push(`\t\t${port.unique_id} [label="input/${port.name}\\n#${eventType}\\n@${eventFreq}", shape=ellipse, fillcolor="#e0f7ff"];`);
                    }
                });
            }

            // Output ports
            if (instance.out_ports && Array.isArray(instance.out_ports)) {
                instance.out_ports.forEach(port => {
                    if (port && port.unique_id && port.name) {
                        dotLines.push(`\t\t${port.unique_id} [label="output/${port.name}", shape=ellipse, fillcolor="#fff4e0"];`);
                    }
                });
            }

            // Events
            if (instance.events && Array.isArray(instance.events)) {
                instance.events.forEach(event => {
                    if (event && event.unique_id && event.name && event.type && event.frequency !== undefined) {
                        const freq = event.frequency !== null ? event.frequency : 'unknown';
                        const shape = event.type === "periodic" ? "diamond" : "box";
                        const mediumColor = instance.vis_guide ? instance.vis_guide.medium_color : "#cccccc";
                        dotLines.push(`\t\t${event.unique_id} [label="${event.name}\\n#${event.type}\\n@${freq}", shape=${shape}, fillcolor="${mediumColor}"];`);
                    }
                });
            }

            dotLines.push(`\t}`);

            // Global topic clouds for input ports
            if (instance.in_ports && Array.isArray(instance.in_ports)) {
                instance.in_ports.forEach(port => {
                    if (port && port.unique_id && port.is_global) {
                        const topicPath = Array.isArray(port.topic) ? port.topic.join('/') : port.topic || '';
                        dotLines.push(`\t${port.unique_id}_cloud [label="/${topicPath}", shape=hexagon, style=solid, color=gray];`);
                        dotLines.push(`\t${port.unique_id}_cloud -> ${port.unique_id} [color="#555577"];`);
                    }
                });
            }

            // Event triggers
            if (instance.events && Array.isArray(instance.events)) {
                instance.events.forEach(event => {
                    if (event && event.unique_id && event.trigger_ids && Array.isArray(event.trigger_ids)) {
                        event.trigger_ids.forEach(triggerId => {
                            if (triggerId) {
                                dotLines.push(`\t${triggerId} -> ${event.unique_id} [color="#555577"];`);
                            }
                        });
                    }
                });
            }

            // Output port triggers
            if (instance.out_ports && Array.isArray(instance.out_ports)) {
                instance.out_ports.forEach(port => {
                    if (port && port.event && port.event.unique_id && port.event.trigger_ids && Array.isArray(port.event.trigger_ids)) {
                        port.event.trigger_ids.forEach(triggerId => {
                            if (triggerId) {
                                dotLines.push(`\t${triggerId} -> ${port.event.unique_id} [color="#555577"];`);
                            }
                        });
                    }
                });
            }

            // Input port triggers
            if (instance.in_ports && Array.isArray(instance.in_ports)) {
                instance.in_ports.forEach(port => {
                    if (port && port.event && port.event.unique_id && port.event.trigger_ids && Array.isArray(port.event.trigger_ids)) {
                        port.event.trigger_ids.forEach(triggerId => {
                            if (triggerId) {
                                dotLines.push(`\t${triggerId} -> ${port.event.unique_id} [color="#555577"];`);
                            }
                        });
                    }
                });
            }

        } else if (instance.entity_type === "module" || instance.entity_type === "system") {
            // Recursively process children for modules and systems
            if (instance.children && Array.isArray(instance.children)) {
                instance.children.forEach(child => {
                    if (child) {
                        this.buildInstanceGraph(child, dotLines);
                    }
                });
            }
        }
    }

    async renderLogicDiagram(dotSyntax) {
        console.log('Rendering logic diagram with DOT syntax length:', dotSyntax.length);
        console.log('Graphviz available:', this.isGraphvizLoaded());

        if (!this.isGraphvizLoaded()) {
            throw new Error('viz.js library not loaded');
        }

        try {
            // Clear container
            this.container.innerHTML = '';
            this.container.className = 'logic-diagram-container';

            // Render DOT using viz.js
            console.log('Rendering DOT with viz.js...');

            // Render SVG using Viz.render
            const svgString = window.Viz.render(dotSyntax, { format: 'svg', engine: 'dot' });
            console.log('SVG generated, length:', svgString.length);

            // Create a container for the SVG
            const svgContainer = document.createElement('div');
            svgContainer.innerHTML = svgString;

            // Get the SVG element
            const svg = svgContainer.querySelector('svg');
            if (svg) {
                // Add interaction handlers
                this.addInteractionHandlers(svg);
                // Initialize pan and zoom on the SVG element
                this.initPanZoom(svg);
            }

            this.container.appendChild(svgContainer);

        } catch (error) {
            console.error('Error rendering logic diagram with viz.js, falling back to text display:', error);

            // Fallback: display DOT syntax as formatted text
            this.container.innerHTML = '';
            this.container.className = 'logic-diagram-container';

            const pre = document.createElement('pre');
            pre.style.cssText = `
                background: #f8f9fa;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                padding: 15px;
                margin: 0;
                font-family: 'Courier New', monospace;
                font-size: 12px;
                line-height: 1.4;
                white-space: pre-wrap;
                word-wrap: break-word;
                max-height: 600px;
                overflow-y: auto;
            `;

            pre.textContent = `// Logic Diagram DOT Syntax\n// Rendering failed: ${error.message}\n\n${dotSyntax}`;
            this.container.appendChild(pre);
        }
    }

    addInteractionHandlers(svgElement) {
        // Add click handlers to nodes and edges
        const nodes = svgElement.querySelectorAll('.node');
        const edges = svgElement.querySelectorAll('.edge');
        const clusters = svgElement.querySelectorAll('.cluster');

        // Handle node clicks
        nodes.forEach(node => {
            node.classList.add('logic-diagram-node');
            node.style.cursor = 'pointer';
            node.addEventListener('click', (e) => {
                e.stopPropagation();
                this.handleElementClick(node, 'Node');
            });
        });

        // Handle edge clicks
        edges.forEach(edge => {
            edge.classList.add('logic-diagram-edge');
            edge.style.cursor = 'pointer';
            edge.addEventListener('click', (e) => {
                e.stopPropagation();
                this.handleElementClick(edge, 'Edge');
            });
        });

        // Handle cluster clicks
        clusters.forEach(cluster => {
            cluster.classList.add('logic-diagram-cluster');
            cluster.style.cursor = 'pointer';
            cluster.addEventListener('click', (e) => {
                e.stopPropagation();
                this.handleElementClick(cluster, 'Cluster');
            });
        });
    }

    handleElementClick(element, type) {
        // Remove previous highlights
        this.container.querySelectorAll('.highlighted').forEach(el => {
            el.classList.remove('highlighted');
        });

        // Highlight clicked element
        element.classList.add('highlighted');

        // Extract element information
        const title = element.querySelector('title');
        const label = element.querySelector('text') || element;
        const elementInfo = {
            type: type,
            label: label ? label.textContent : 'Unknown',
            title: title ? title.textContent : ''
        };

        // Update info panel
        this.updateInfoPanel(elementInfo, type);
    }

    initPanZoom(svg) {
        if (this.panZoomInstance) {
            this.panZoomInstance.destroy();
        }

        // Initialize svg-pan-zoom
        this.panZoomInstance = svgPanZoom(svg, {
            zoomEnabled: true,
            controlIconsEnabled: true,
            fit: true,
            center: true,
            minZoom: 0.1,
            maxZoom: 5,
            zoomScaleSensitivity: 0.2
        });

        // Fit to screen initially
        setTimeout(() => {
            this.panZoomInstance.fit();
            this.panZoomInstance.center();
        }, 100);
    }

    updateInfoPanel(data, type) {
        // This will be handled by the parent overview page
        if (this.options.onInfoUpdate) {
            this.options.onInfoUpdate(data, type);
        }
    }

    showError(message) {
        this.container.innerHTML = `<div style="display: flex; justify-content: center; align-items: center; height: 100%; color: #dc3545;">${message}</div>`;
    }

    destroy() {
        // Clean up pan zoom instance
        if (this.panZoomInstance) {
            this.panZoomInstance.destroy();
            this.panZoomInstance = null;
        }
        this.container.innerHTML = '';
    }
}

// Export for use in the overview page
window.LogicDiagramModule = LogicDiagramModule;
