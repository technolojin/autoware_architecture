<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Autoware Architecture Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/elkjs@0.9.3/lib/elk.bundled.js"></script>
    <style>
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            margin: 0; 
            padding: 0; 
            display: flex; 
            height: 100vh; 
            overflow: hidden;
            background-color: #f8f9fa;
        }
        #sidebar {
            width: 320px;
            background: #ffffff;
            border-right: 1px solid #e9ecef;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            z-index: 2;
            box-shadow: 2px 0 10px rgba(0,0,0,0.05);
        }
        #mode-selector {
            padding: 10px;
            font-size: 14px;
            margin-bottom: 20px;
            width: 100%;
            border: 1px solid #ced4da;
            border-radius: 4px;
        }
        #info-panel {
            flex-grow: 1;
            overflow-y: auto;
        }
        .info-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            margin-bottom: 10px;
        }
        .info-title { 
            font-weight: 600; 
            margin-bottom: 8px; 
            color: #212529; 
            border-bottom: 2px solid #dee2e6; 
            padding-bottom: 5px;
            font-size: 14px;
        }
        .info-row { margin-bottom: 4px; font-size: 13px; display: flex; }
        .info-label { color: #6c757d; font-weight: 500; width: 80px; flex-shrink: 0; }
        .info-value { color: #212529; font-family: 'Consolas', monospace; word-break: break-all; }
        
        #canvas-container {
            flex-grow: 1;
            background: #ffffff;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }
        #canvas-container:active {
            cursor: grabbing;
        }
        
        /* SVG Styles */
        svg {
            width: 100%;
            height: 100%;
        }
        
        .node-rect {
            stroke-width: 1.5px;
            transition: all 0.2s;
        }
        .node-label {
            font-family: 'Segoe UI', sans-serif;
            font-size: 12px;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
        }
        
        .port-rect {
            stroke: #6c757d;
            stroke-width: 1px;
            fill: #e9ecef;
            transition: all 0.1s;
        }
        .port-label {
            font-family: 'Segoe UI', sans-serif;
            font-size: 9px;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
        }
        
        .edge-path {
            fill: none;
            stroke: #adb5bd;
            stroke-width: 1.5px;
            transition: all 0.2s;
        }
        .edge-arrow {
            fill: #adb5bd;
        }
        
        /* Highlighting */
        .highlighted .node-rect {
            stroke: #0d6efd !important;
            stroke-width: 2.5px;
        }
        .highlighted .edge-path {
            stroke: #0d6efd !important;
            stroke-width: 2.5px;
        }
        .highlighted .edge-arrow {
            fill: #0d6efd !important;
            stroke-width: 2.5px;
        }
        
        .port-highlighted {
            stroke: #0d6efd !important;
            stroke-width: 2px;
            fill: #cfe2ff;
        }
        
        /* Loading overlay */
        #loading {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.9);
            display: flex; justify-content: center; align-items: center;
            flex-direction: column;
            font-size: 18px; color: #495057;
            z-index: 100;
            display: none;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #0d6efd;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Debug Console */
        #debug-console {
            position: absolute;
            bottom: 0;
            left: 320px; /* Sidebar width */
            right: 0;
            height: 150px;
            background: rgba(0,0,0,0.8);
            color: #0f0;
            font-family: monospace;
            font-size: 12px;
            padding: 10px;
            overflow-y: auto;
            z-index: 1000;
            display: none; /* Hidden by default, shown on error */
        }
        .log-error { color: #ff4444; }
        .log-warn { color: #ffbb33; }
        .log-info { color: #00ccff; }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">Layout calculation in progress...</div>
    </div>
    
    <div id="sidebar">
        <h2 style="margin-top: 0; color: #212529;">Architecture</h2>
        <label for="mode-selector" style="color: #495057; font-weight: 500; margin-bottom: 5px; display: block;">View Mode:</label>
        <select id="mode-selector">
            {% for mode in modes %}
            <option value="{{ mode }}" {% if mode == default_mode %}selected{% endif %}>{{ mode }}</option>
            {% endfor %}
        </select>
        
        <div id="info-panel">
            <div class="info-card">
                <div class="info-row" style="color: #6c757d;">Select a node or edge to see details.</div>
            </div>
        </div>
        
        <div style="margin-top: 20px;">
            <button onclick="document.getElementById('debug-console').style.display = 'block'" style="padding: 5px 10px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Show Debug Log</button>
        </div>
    </div>
    
    <div id="canvas-container">
        <svg id="main-svg">
            <g id="zoom-layer"></g>
        </svg>
    </div>

    <div id="debug-console"></div>

    <script>
        // Custom Logger
        const debugConsole = document.getElementById('debug-console');
        function log(msg, type='info') {
            console.log(msg);
            const line = document.createElement('div');
            line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            line.className = `log-${type}`;
            debugConsole.appendChild(line);
            debugConsole.scrollTop = debugConsole.scrollHeight;
            if (type === 'error') debugConsole.style.display = 'block';
        }

        document.addEventListener('DOMContentLoaded', function() {
            if (typeof ELK === 'undefined') {
                log("CRITICAL: ELK.js library not loaded! Check internet connection or CDN URL.", 'error');
                alert("ELK.js library failed to load. Please check your internet connection.");
                return;
            }

            const elk = new ELK();
            const selector = document.getElementById('mode-selector');
            const infoPanel = document.getElementById('info-panel');
            const loading = document.getElementById('loading');
            const svg = document.getElementById('main-svg');
            const zoomLayer = document.getElementById('zoom-layer');
            const container = document.getElementById('canvas-container');
            
            let currentGraph = null;
            let transform = { x: 0, y: 0, k: 1 };
            let isDragging = false;
            let startPoint = { x: 0, y: 0 };
            
            // Data store for interactions (decoupled from ELK graph)
            let elementData = new Map();

            // --- UI Helpers ---
            function showLoading(show, text) {
                loading.style.display = show ? 'flex' : 'none';
                if(text) document.getElementById('loading-text').innerText = text;
            }

            function updateInfo(data, type) {
                let html = `<div class="info-card"><div class="info-title">${type} Details</div>`;
                
                function displayProps(obj) {
                    let str = '';
                    for (const [key, value] of Object.entries(obj)) {
                        if (['id', 'children', 'edges', 'ports', 'layoutOptions', 'width', 'height', 'x', 'y', 'source', 'target', 'sections'].includes(key)) continue;
                        
                        let displayValue = value;
                        if (typeof value === 'object' && value !== null) {
                            if (Array.isArray(value)) displayValue = '[' + value.length + ']';
                            else displayValue = '{...}';
                        }
                        
                        str += `<div class="info-row">
                            <span class="info-label">${key}:</span> 
                            <span class="info-value">${displayValue}</span>
                        </div>`;
                    }
                    return str;
                }
                
                html += displayProps(data);
                html += '</div>';
                infoPanel.innerHTML = html;
            }

            // --- Data Transformation (App Data -> ELK JSON) ---
            function transformDataToElk(root) {
                log("Starting data transformation...");
                elementData.clear();
                
                function convertNode(instance) {
                    if (!instance) {
                        log("Warning: Encountered null instance", 'warn');
                        return null;
                    }
                    
                    // Ensure unique_id exists
                    if (instance.unique_id === undefined || instance.unique_id === null) {
                        log("Error: Instance missing unique_id", 'error');
                        console.error("Instance missing unique_id:", instance);
                        return null;
                    }

                    const nodeId = String(instance.unique_id);
                    elementData.set(nodeId, instance);

                    const inPortsCount = (instance.in_ports || []).length;
                    const outPortsCount = (instance.out_ports || []).length;
                    const maxPorts = Math.max(inPortsCount, outPortsCount);
                    const nodeHeight = Math.max(100, 80 + maxPorts * 25);

                    const node = {
                        id: nodeId,
                        labels: [
                            { text: (instance.namespace && instance.namespace.join('/')) || "" },
                            { text: instance.name || nodeId || "Unnamed" }
                        ],
                        width: 300, 
                        height: nodeHeight,
                        children: [],
                        ports: [],
                        properties: {
                            'org.eclipse.elk.portConstraints': 'FIXED_SIDE',
                            'org.eclipse.elk.nodeLabels.placement': 'H_CENTER V_TOP',
                            'org.eclipse.elk.portLabels.placement': 'INSIDE',
                            'org.eclipse.elk.portAlignment.default': 'CENTER',
                            'org.eclipse.elk.spacing.portPort': '15'
                        }
                    };

                    // Add position guide if available
                    const visGuide = instance.vis_guide || {};
                    if (visGuide.position && Array.isArray(visGuide.position)) {
                        node.properties['org.eclipse.elk.layered.layerIndex'] = visGuide.position[0];
                        node._sortOrder = visGuide.position[1];
                    }

                    // Ports
                    if (instance.in_ports) {
                        instance.in_ports.forEach(port => {
                            if (!port.unique_id) {
                                log(`Warning: Port missing ID in node ${instance.unique_id}`, 'warn');
                                return;
                            }
                            // Create a lightweight copy of userData
                            const portData = { ...port };
                            const portId = String(port.unique_id);
                            elementData.set(portId, portData);

                            node.ports.push({
                                id: portId,
                                width: 10,
                                height: 10,
                                properties: {
                                    'org.eclipse.elk.port.side': 'WEST'
                                },
                                labels: [{ 
                                    text: port.name || "Port",
                                    width: ((port.name && port.name.length) || 4) * 6,
                                    height: 10
                                }]
                            });
                        });
                    }
                    if (instance.out_ports) {
                        instance.out_ports.forEach(port => {
                            if (!port.unique_id) {
                                log(`Warning: Port missing ID in node ${instance.unique_id}`, 'warn');
                                return;
                            }
                            // Create a lightweight copy of userData
                            const portData = { ...port };
                            const portId = String(port.unique_id);
                            elementData.set(portId, portData);

                            node.ports.push({
                                id: portId,
                                width: 10,
                                height: 10,
                                properties: {
                                    'org.eclipse.elk.port.side': 'EAST'
                                },
                                labels: [{ 
                                    text: port.name,
                                    width: ((port.name && port.name.length) || 4) * 6,
                                    height: 10
                                }]
                            });
                        });
                    }

                    // Children
                    if (instance.children && instance.children.length > 0) {
                        const childNodes = [];
                        instance.children.forEach(child => {
                            const childNode = convertNode(child);
                            if (childNode) childNodes.push(childNode);
                        });
                        
                        // Sort based on _sortOrder (y position)
                        childNodes.sort((a, b) => {
                            const aY = (a._sortOrder !== undefined) ? a._sortOrder : 999;
                            const bY = (b._sortOrder !== undefined) ? b._sortOrder : 999;
                            return aY - bY;
                        });

                        node.children = childNodes;
                        
                        // Only remove dimensions if we actually added children
                        if (node.children.length > 0) {
                            delete node.width;
                            delete node.height;
                        }
                    }

                    // Links
                    if (instance.links) {
                        node.edges = [];
                        instance.links.forEach((link, index) => {
                            if (!link.from_port || !link.to_port) {
                                log(`Warning: Skipping invalid link in ${instance.name}`, 'warn');
                                return;
                            }
                            // Lightweight user data
                            const linkData = { ...link };
                            const edgeId = `edge_${link.from_port.unique_id}_${link.to_port.unique_id}_${index}`;
                            elementData.set(edgeId, linkData);
                            
                            node.edges.push({
                                id: edgeId,
                                sources: [String(link.from_port.unique_id)],
                                targets: [String(link.to_port.unique_id)],
                                properties: {}
                            });
                        });
                    }

                    return node;
                }

                const rootNode = convertNode(root);
                
                // Ensure Root Node is treated as a compound node (no dimensions, correct algorithm)
                if (rootNode) {
                    delete rootNode.width;
                    delete rootNode.height;
                    // Ensure root has ID
                    if (!rootNode.id) rootNode.id = 'root';
                }

                log(`Transformation complete. Nodes: ${rootNode?.children?.length || 0}`);
                console.log("ELK Graph JSON:", JSON.stringify(rootNode, null, 2));
                return rootNode;
            }

            // --- Validation ---
            function validateGraph(rootNode) {
                log("Validating graph structure...");
                const allIds = new Map();
                const portIds = new Set();
                let errors = 0;

                function traverse(node) {
                    if (!node.id) {
                        log("Error: Node missing ID", 'error');
                        errors++;
                    }
                    
                    // Check dimensions for leaf nodes (crucial for ELK)
                    if ((!node.children || node.children.length === 0) && (node.width === undefined || node.height === undefined)) {
                        log(`Error: Node ${node.id || 'unknown'} has no dimensions and no children.`, 'error');
                        errors++;
                    }

                    if (node.id) {
                        if (allIds.has(node.id)) {
                            const existing = allIds.get(node.id);
                            log(`Error: Duplicate Node ID: ${node.id}`, 'error');
                            log(`  Existing: ${existing.type} '${existing.name}'`, 'error');
                            log(`  New: Node '${node.labels[0].text}'`, 'error');
                            errors++;
                        }
                        allIds.set(node.id, { type: 'Node', name: node.labels[0].text });
                    }

                    if (node.ports) {
                        node.ports.forEach(port => {
                            if (!port.id) {
                                log("Error: Port missing ID", 'error');
                                errors++;
                            } else {
                                if (allIds.has(port.id)) {
                                    const existing = allIds.get(port.id);
                                    log(`Error: Duplicate Port ID: ${port.id}`, 'error');
                                    log(`  Existing: ${existing.type} '${existing.name}'`, 'error');
                                    log(`  New: Port '${port.labels[0].text}'`, 'error');
                                    errors++;
                                }
                                allIds.set(port.id, { type: 'Port', name: port.labels[0].text });
                                portIds.add(port.id);
                            }
                        });
                    }

                    if (node.children) {
                        node.children.forEach(traverse);
                    }
                }

                traverse(rootNode);

                function validateEdges(node) {
                    if (node.edges) {
                        node.edges.forEach(edge => {
                            if (!edge.id) {
                                log("Error: Edge missing ID", 'error');
                                errors++;
                            } else {
                                if (allIds.has(edge.id)) {
                                    log(`Error: Duplicate Edge ID: ${edge.id}`, 'error');
                                    errors++;
                                }
                                allIds.set(edge.id, { type: 'Edge', name: edge.id });
                            }
                            
                            if (edge.sources) {
                                edge.sources.forEach(src => {
                                    if (!portIds.has(src)) {
                                        log(`Error: Edge ${edge.id} references non-existent source port: ${src}`, 'error');
                                        errors++;
                                    }
                                });
                            } else {
                                log(`Error: Edge ${edge.id} missing sources`, 'error');
                                errors++;
                            }

                            if (edge.targets) {
                                edge.targets.forEach(tgt => {
                                    if (!portIds.has(tgt)) {
                                        log(`Error: Edge ${edge.id} references non-existent target port: ${tgt}`, 'error');
                                        errors++;
                                    }
                                });
                            } else {
                                log(`Error: Edge ${edge.id} missing targets`, 'error');
                                errors++;
                            }
                        });
                    }
                    
                    if (node.children) {
                        node.children.forEach(validateEdges);
                    }
                }
                
                validateEdges(rootNode);

                if (errors > 0) {
                    log(`Validation failed with ${errors} errors. See log above.`, 'error');
                    return false;
                }
                log("Validation passed.");
                return true;
            }

            // --- Layout & Rendering ---
            function layoutAndRender(graphData) {
                if (!validateGraph(graphData)) {
                    alert("Graph validation failed. Check debug log.");
                    showLoading(false);
                    return;
                }

                showLoading(true, "Calculating Layout...");
                log("Starting ELK layout...");
                
                const elkOptions = {
                    'algorithm': 'layered',
                    'org.eclipse.elk.direction': 'RIGHT',
                    'org.eclipse.elk.spacing.nodeNode': '60',
                    'org.eclipse.elk.spacing.edgeNode': '30',
                    'org.eclipse.elk.edgeRouting': 'ORTHOGONAL',
                    'org.eclipse.elk.layered.spacing.edgeNodeBetweenLayers': '30',
                    'org.eclipse.elk.layered.nodePlacement.strategy': 'BRANDES_KOEPF',
                    'org.eclipse.elk.layered.layering.strategy': 'INTERACTIVE',
                    'org.eclipse.elk.padding': '[top=50,left=50,bottom=50,right=50]'
                };

                elk.layout(graphData, { layoutOptions: elkOptions })
                    .then(graph => {
                        log("Layout successful!");
                        currentGraph = graph;
                        renderGraph(graph);
                        showLoading(false);
                        fitToScreen();
                    })
                    .catch(err => {
                        log("Layout Error: " + err.message, 'error');
                        console.error(err);
                        showLoading(false);
                        alert("Layout Error: " + err.message);
                    });
            }

            function renderGraph(graph) {
                log("Rendering graph...");
                zoomLayer.innerHTML = '';
                
                const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
                defs.innerHTML = `
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                    refX="10" refY="3.5" orient="auto">
                      <polygon points="0 0, 10 3.5, 0 7" fill="#adb5bd" />
                    </marker>
                    <marker id="arrowhead-active" markerWidth="10" markerHeight="7" 
                    refX="10" refY="3.5" orient="auto">
                      <polygon points="0 0, 10 3.5, 0 7" fill="#0d6efd" />
                    </marker>
                `;
                zoomLayer.appendChild(defs);

                let nodeCount = 0;
                let edgeCount = 0;

                const edgeIdToElement = new Map();
                const portToEdges = new Map();

                function registerEdge(edgeId, sources, targets, element) {
                    edgeIdToElement.set(edgeId, element);
                    if (sources) {
                        sources.forEach(src => {
                            if (!portToEdges.has(src)) portToEdges.set(src, []);
                            portToEdges.get(src).push(edgeId);
                        });
                    }
                    if (targets) {
                        targets.forEach(tgt => {
                            if (!portToEdges.has(tgt)) portToEdges.set(tgt, []);
                            portToEdges.get(tgt).push(edgeId);
                        });
                    }
                }

                function highlightConnected(portId) {
                    document.querySelectorAll('.highlighted').forEach(el => el.classList.remove('highlighted'));
                    document.querySelectorAll('.port-highlighted').forEach(el => el.classList.remove('port-highlighted'));
                    document.querySelectorAll('.edge-path').forEach(el => el.setAttribute("marker-end", "url(#arrowhead)"));
                    
                    const edgeIds = portToEdges.get(portId) || [];
                    edgeIds.forEach(id => {
                        const el = edgeIdToElement.get(id);
                        if (el) {
                            el.classList.add('highlighted');
                            el.setAttribute("marker-end", "url(#arrowhead-active)");
                        }
                    });
                }

                function renderNode(node, parentGroup, depth = 0) {
                    nodeCount++;
                    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    g.setAttribute("transform", `translate(${node.x},${node.y})`);
                    g.classList.add("node-group");
                    
                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute("width", node.width);
                    rect.setAttribute("height", node.height);
                    rect.setAttribute("rx", 4);
                    rect.classList.add("node-rect");
                    
                    const userData = elementData.get(node.id) || {};
                    const visGuide = userData.vis_guide || {};
                    let fillColor = visGuide.background_color || "#ffffff";
                    if (userData.entity_type === "node") {
                        fillColor = visGuide.medium_color || fillColor;
                    }
                    rect.setAttribute("fill", fillColor);
                    rect.setAttribute("stroke", visGuide.color || "#333");
                    
                    rect.onclick = (e) => {
                        e.stopPropagation();
                        updateInfo(userData, 'Node');
                        highlight(g);
                    };
                    
                    g.appendChild(rect);

                    if (node.labels && node.labels.length > 0) {
                        const fontSize = Math.max(12, 36 - (depth * 5));
                        
                        let nsLineCount = 0;
                        // Namespace Label (smaller, above)
                        if (node.labels.length > 1 && node.labels[0].text) {
                            const fullText = "/" + node.labels[0].text + "/";
                            const maxWidth = node.width - 20; // Padding
                            const charWidth = 6; // Approximate width per char at 10px size
                            const maxCharsPerLine = Math.floor(maxWidth / charWidth);
                            
                            const parts = fullText.split('/');
                            let lines = [];
                            let currentLine = "";
                            
                            // Reconstruct path with wrapping
                            for(let i=0; i<parts.length; i++) {
                                const part = parts[i];
                                if(!part && i > 0 && i < parts.length-1) continue; // Skip empty mid-splits but keep rendering logic
                                
                                const prefix = (currentLine && !currentLine.endsWith('/')) ? "/" : "";
                                const suffix = (i < parts.length - 1) ? "" : ""; // Don't force suffix yet
                                
                                const testLine = currentLine + prefix + part;
                                
                                if (testLine.length > maxCharsPerLine && currentLine.length > 0) {
                                    lines.push(currentLine + "/");
                                    currentLine = part;
                                } else {
                                    currentLine = testLine;
                                }
                            }
                            if (currentLine) lines.push(currentLine);
                            
                            // Force break if single line is still too long (e.g. long name without slashes)
                            if (lines.length === 1 && lines[0].length > maxCharsPerLine) {
                                const longLine = lines[0];
                                lines = [];
                                for (let i = 0; i < longLine.length; i += maxCharsPerLine) {
                                    lines.push(longLine.substring(i, i + maxCharsPerLine));
                                }
                            } else if (lines.length === 0) {
                                lines.push(fullText); // Fallback
                            }

                            nsLineCount = lines.length;
                            lines.forEach((line, index) => {
                                const nsText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                                nsText.setAttribute("x", node.width / 2);
                                nsText.setAttribute("y", 10 + (index * 6)); // 6px line height
                                nsText.textContent = line;
                                nsText.classList.add("node-label");
                                nsText.style.fontSize = "5px";
                                nsText.style.fill = "#6c757d";
                                g.appendChild(nsText);
                            });
                        }

                        // Name Label
                        const nameText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        nameText.setAttribute("x", node.width / 2);
                        // Push down based on namespace lines. Base offset 15, +6 per line. Extra padding 5.
                        const nsOffset = nsLineCount > 0 ? (10 + (nsLineCount * 6) + fontSize / 2) : (10 + fontSize / 2);
                        
                        nameText.setAttribute("y", nsOffset);
                        nameText.textContent = node.labels[node.labels.length - 1].text;
                        nameText.classList.add("node-label");
                        nameText.style.fontSize = `${fontSize}px`;
                        if (depth <= 1) nameText.style.fontWeight = "bold";
                        g.appendChild(nameText);
                    }

                    if (node.ports) {
                        node.ports.forEach(port => {
                            const pg = document.createElementNS("http://www.w3.org/2000/svg", "g");
                            pg.setAttribute("transform", `translate(${port.x},${port.y})`);
                            
                            const prect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                            prect.setAttribute("width", port.width);
                            prect.setAttribute("height", port.height);
                            prect.classList.add("port-rect");
                            
                            const title = document.createElementNS("http://www.w3.org/2000/svg", "title");
                            const portData = elementData.get(port.id) || {};
                            title.textContent = portData.name || "Port";
                            prect.appendChild(title);

                            pg.onclick = (e) => {
                                e.stopPropagation();
                                updateInfo(portData, 'Port');
                                highlightConnected(port.id);
                                prect.classList.add('port-highlighted');
                            };
                            pg.style.cursor = 'pointer';

                            pg.appendChild(prect);

                            if (port.labels) {
                                port.labels.forEach(label => {
                                    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                                    text.setAttribute("x", (label.x || 0) + (label.width || 0) / 2);
                                    text.setAttribute("y", (label.y || 0) + (label.height || 0) / 2);
                                    text.textContent = label.text;
                                    text.classList.add("port-label");
                                    pg.appendChild(text);
                                });
                            }

                            g.appendChild(pg);
                        });
                    }

                    if (node.children) {
                        node.children.forEach(child => renderNode(child, g, depth + 1));
                    }

                    if (node.edges) {
                        node.edges.forEach(edge => {
                            edgeCount++;
                            if (!edge.sections) return;
                            
                            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                            let d = "";
                            edge.sections.forEach(section => {
                                d += `M ${section.startPoint.x} ${section.startPoint.y} `;
                                if (section.bendPoints) {
                                    section.bendPoints.forEach(bp => {
                                        d += `L ${bp.x} ${bp.y} `;
                                    });
                                }
                                d += `L ${section.endPoint.x} ${section.endPoint.y} `;
                            });
                            
                            path.setAttribute("d", d);
                            path.classList.add("edge-path");
                            path.setAttribute("marker-end", "url(#arrowhead)");
                            
                            const userData = elementData.get(edge.id) || {};
                            path.onclick = (e) => {
                                e.stopPropagation();
                                updateInfo(userData, 'Link');
                                document.querySelectorAll('.highlighted').forEach(el => el.classList.remove('highlighted'));
                                document.querySelectorAll('.port-highlighted').forEach(el => el.classList.remove('port-highlighted'));
                                path.classList.add('highlighted');
                                path.setAttribute("marker-end", "url(#arrowhead-active)");
                            };
                            
                            registerEdge(edge.id, edge.sources, edge.targets, path);

                            g.appendChild(path);
                        });
                    }

                    parentGroup.appendChild(g);
                }

                renderNode(graph, zoomLayer);
                log(`Rendered ${nodeCount} nodes and ${edgeCount} edges.`);
            }

            function highlight(element) {
                document.querySelectorAll('.highlighted').forEach(el => el.classList.remove('highlighted'));
                document.querySelectorAll('.edge-path').forEach(el => el.setAttribute("marker-end", "url(#arrowhead)"));
                element.classList.add('highlighted');
            }

            // --- Zoom/Pan ---
            function updateTransform() {
                zoomLayer.setAttribute("transform", `translate(${transform.x},${transform.y}) scale(${transform.k})`);
            }

            function fitToScreen() {
                if (!currentGraph) return;
                const bounds = zoomLayer.getBBox();
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                if (bounds.width === 0 || bounds.height === 0) {
                    log("Warning: Graph bounds are zero.", 'warn');
                    return;
                }

                const scale = Math.min(
                    (containerWidth - 40) / bounds.width,
                    (containerHeight - 40) / bounds.height
                );
                
                transform.k = Math.min(scale, 1);
                transform.x = (containerWidth - bounds.width * transform.k) / 2 - bounds.x * transform.k;
                transform.y = (containerHeight - bounds.height * transform.k) / 2 - bounds.y * transform.k;
                
                updateTransform();
            }

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomIntensity = 0.1;
                const delta = e.deltaY > 0 ? -zoomIntensity : zoomIntensity;
                const newScale = transform.k * (1 + delta);
                
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                transform.x -= (mouseX - transform.x) * delta;
                transform.y -= (mouseY - transform.y) * delta;
                transform.k = newScale;
                
                updateTransform();
            });

            container.addEventListener('mousedown', (e) => {
                isDragging = true;
                startPoint = { x: e.clientX - transform.x, y: e.clientY - transform.y };
            });

            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                e.preventDefault();
                transform.x = e.clientX - startPoint.x;
                transform.y = e.clientY - startPoint.y;
                updateTransform();
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // --- Initialization ---
            function loadMode(mode) {
                showLoading(true, "Loading Data...");
                log(`Loading mode: ${mode}`);
                
                const initData = () => {
                    if (window.architectureData && window.architectureData[mode]) {
                        try {
                            const elkGraph = transformDataToElk(window.architectureData[mode]);
                            layoutAndRender(elkGraph);
                        } catch(e) {
                            log("Error processing data: " + e.message, 'error');
                            console.error(e);
                            alert("Error processing data: " + e.message);
                            showLoading(false);
                        }
                    } else {
                        log("Failed to load data for mode: " + mode, 'error');
                        alert("Failed to load data for mode: " + mode);
                        showLoading(false);
                    }
                };

                if (window.architectureData && window.architectureData[mode]) {
                    initData();
                    return;
                }
                
                const script = document.createElement('script');
                script.src = `data/${mode}.js`;
                script.onload = initData;
                script.onerror = function(e) {
                    log("Error loading script for mode: " + mode, 'error');
                    showLoading(false);
                    alert("Error loading script for mode: " + mode);
                };
                document.body.appendChild(script);
            }

            loadMode(selector.value);
            
            selector.addEventListener('change', function(e) {
                loadMode(e.target.value);
            });
        });
    </script>
</body>
</html>
