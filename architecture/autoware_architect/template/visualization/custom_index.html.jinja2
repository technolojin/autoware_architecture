<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Autoware Architecture Visualization (ELK)</title>
    <script src="https://cdn.jsdelivr.net/npm/elkjs@0.8.2/lib/elk.bundled.js"></script>
    <style>
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            margin: 0; 
            padding: 0; 
            display: flex; 
            height: 100vh; 
            overflow: hidden;
            background-color: #f8f9fa;
        }
        #sidebar {
            width: 320px;
            background: #ffffff;
            border-right: 1px solid #e9ecef;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            z-index: 2;
            box-shadow: 2px 0 10px rgba(0,0,0,0.05);
        }
        #mode-selector {
            padding: 10px;
            font-size: 14px;
            margin-bottom: 20px;
            width: 100%;
            border: 1px solid #ced4da;
            border-radius: 4px;
        }
        #info-panel {
            flex-grow: 1;
            overflow-y: auto;
        }
        .info-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            margin-bottom: 10px;
        }
        .info-title { 
            font-weight: 600; 
            margin-bottom: 8px; 
            color: #212529; 
            border-bottom: 2px solid #dee2e6; 
            padding-bottom: 5px;
            font-size: 14px;
        }
        .info-row { margin-bottom: 4px; font-size: 13px; display: flex; }
        .info-label { color: #6c757d; font-weight: 500; width: 80px; flex-shrink: 0; }
        .info-value { color: #212529; font-family: 'Consolas', monospace; word-break: break-all; }
        
        #canvas-container {
            flex-grow: 1;
            background: #ffffff;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }
        #canvas-container:active {
            cursor: grabbing;
        }
        
        /* SVG Styles */
        svg {
            width: 100%;
            height: 100%;
        }
        
        .node-rect {
            stroke-width: 1.5px;
            transition: all 0.2s;
        }
        .node-label {
            font-family: 'Segoe UI', sans-serif;
            font-size: 12px;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
        }
        
        .port-rect {
            stroke: #6c757d;
            stroke-width: 1px;
            fill: #e9ecef;
            transition: all 0.1s;
        }
        .port-label {
            font-family: 'Segoe UI', sans-serif;
            font-size: 9px;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
        }
        
        .edge-path {
            fill: none;
            stroke: #adb5bd;
            stroke-width: 1.5px;
            transition: all 0.2s;
        }
        .edge-arrow {
            fill: #adb5bd;
        }
        
        /* Highlighting */
        .highlighted .node-rect {
            stroke: #0d6efd !important;
            stroke-width: 2.5px;
        }
        .highlighted .edge-path {
            stroke: #0d6efd !important;
            stroke-width: 2.5px;
        }
        .highlighted .edge-arrow {
            fill: #0d6efd !important;
        }
        
        /* Loading overlay */
        #loading {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.9);
            display: flex; justify-content: center; align-items: center;
            flex-direction: column;
            font-size: 18px; color: #495057;
            z-index: 100;
            display: none;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #0d6efd;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Debug Console */
        #debug-console {
            position: absolute;
            bottom: 0;
            left: 320px; /* Sidebar width */
            right: 0;
            height: 150px;
            background: rgba(0,0,0,0.8);
            color: #0f0;
            font-family: monospace;
            font-size: 12px;
            padding: 10px;
            overflow-y: auto;
            z-index: 1000;
            display: none; /* Hidden by default, shown on error */
        }
        .log-error { color: #ff4444; }
        .log-warn { color: #ffbb33; }
        .log-info { color: #00ccff; }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">Layout calculation in progress...</div>
    </div>
    
    <div id="sidebar">
        <h2 style="margin-top: 0; color: #212529;">Architecture</h2>
        <label for="mode-selector" style="color: #495057; font-weight: 500; margin-bottom: 5px; display: block;">View Mode:</label>
        <select id="mode-selector">
            {% for mode in modes %}
            <option value="{{ mode }}" {% if mode == default_mode %}selected{% endif %}>{{ mode }}</option>
            {% endfor %}
        </select>
        
        <div id="info-panel">
            <div class="info-card">
                <div class="info-row" style="color: #6c757d;">Select a node or edge to see details.</div>
            </div>
        </div>
        
        <div style="margin-top: 20px;">
            <button onclick="document.getElementById('debug-console').style.display = 'block'" style="padding: 5px 10px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Show Debug Log</button>
        </div>
    </div>
    
    <div id="canvas-container">
        <svg id="main-svg">
            <g id="zoom-layer"></g>
        </svg>
    </div>

    <div id="debug-console"></div>

    <script>
        // Custom Logger
        const debugConsole = document.getElementById('debug-console');
        function log(msg, type='info') {
            console.log(msg);
            const line = document.createElement('div');
            line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            line.className = `log-${type}`;
            debugConsole.appendChild(line);
            debugConsole.scrollTop = debugConsole.scrollHeight;
            if (type === 'error') debugConsole.style.display = 'block';
        }

        document.addEventListener('DOMContentLoaded', function() {
            if (typeof ELK === 'undefined') {
                log("CRITICAL: ELK.js library not loaded! Check internet connection or CDN URL.", 'error');
                alert("ELK.js library failed to load. Please check your internet connection.");
                return;
            }

            const elk = new ELK();
            const selector = document.getElementById('mode-selector');
            const infoPanel = document.getElementById('info-panel');
            const loading = document.getElementById('loading');
            const svg = document.getElementById('main-svg');
            const zoomLayer = document.getElementById('zoom-layer');
            const container = document.getElementById('canvas-container');
            
            let currentGraph = null;
            let transform = { x: 0, y: 0, k: 1 };
            let isDragging = false;
            let startPoint = { x: 0, y: 0 };

            // --- UI Helpers ---
            function showLoading(show, text) {
                loading.style.display = show ? 'flex' : 'none';
                if(text) document.getElementById('loading-text').innerText = text;
            }

            function updateInfo(data, type) {
                let html = `<div class="info-card"><div class="info-title">${type} Details</div>`;
                
                function displayProps(obj) {
                    let str = '';
                    for (const [key, value] of Object.entries(obj)) {
                        if (['id', 'children', 'edges', 'ports', 'layoutOptions', 'width', 'height', 'x', 'y', 'source', 'target', 'sections'].includes(key)) continue;
                        
                        let displayValue = value;
                        if (typeof value === 'object' && value !== null) {
                            if (Array.isArray(value)) displayValue = '[' + value.length + ']';
                            else displayValue = '{...}';
                        }
                        
                        str += `<div class="info-row">
                            <span class="info-label">${key}:</span> 
                            <span class="info-value">${displayValue}</span>
                        </div>`;
                    }
                    return str;
                }
                
                html += displayProps(data);
                html += '</div>';
                infoPanel.innerHTML = html;
            }

            // --- Data Transformation (App Data -> ELK JSON) ---
            function transformDataToElk(root) {
                log("Starting data transformation...");
                const edges = [];
                
                function convertNode(instance) {
                    if (!instance) {
                        log("Warning: Encountered null instance", 'warn');
                        return null;
                    }

                    const node = {
                        id: instance.unique_id,
                        labels: [{ text: instance.name || "Unnamed" }],
                        width: 200, 
                        height: 100,
                        children: [],
                        ports: [],
                        properties: {
                            'org.eclipse.elk.portConstraints': 'FIXED_SIDE',
                            'org.eclipse.elk.nodeLabels.placement': 'H_CENTER V_TOP',
                            'userData': instance
                        }
                    };

                    // Ports
                    if (instance.in_ports) {
                        instance.in_ports.forEach(port => {
                            node.ports.push({
                                id: port.unique_id,
                                width: 10,
                                height: 10,
                                properties: {
                                    'org.eclipse.elk.port.side': 'WEST',
                                    'userData': port
                                },
                                labels: [{ text: port.name }] 
                            });
                        });
                    }
                    if (instance.out_ports) {
                        instance.out_ports.forEach(port => {
                            node.ports.push({
                                id: port.unique_id,
                                width: 10,
                                height: 10,
                                properties: {
                                    'org.eclipse.elk.port.side': 'EAST',
                                    'userData': port
                                },
                                labels: [{ text: port.name }]
                            });
                        });
                    }

                    // Children
                    if (instance.children && instance.children.length > 0) {
                        instance.children.forEach(child => {
                            const childNode = convertNode(child);
                            if (childNode) node.children.push(childNode);
                        });
                        delete node.width;
                        delete node.height;
                    }

                    // Links
                    if (instance.links) {
                        instance.links.forEach(link => {
                            if (!link.from_port || !link.to_port) {
                                log(`Warning: Skipping invalid link in ${instance.name}`, 'warn');
                                return;
                            }
                            edges.push({
                                id: `edge_${link.from_port.unique_id}_${link.to_port.unique_id}`,
                                sources: [link.from_port.unique_id],
                                targets: [link.to_port.unique_id],
                                properties: {
                                    'userData': link
                                }
                            });
                        });
                    }

                    return node;
                }

                const rootNode = convertNode(root);
                
                // Attach all edges to root
                rootNode.edges = edges;

                log(`Transformation complete. Nodes: ${rootNode.children.length}, Edges: ${edges.length}`);
                return rootNode;
            }

            // --- Validation ---
            function validateGraph(rootNode) {
                log("Validating graph structure...");
                const allIds = new Map();
                const portIds = new Set();
                let errors = 0;

                function traverse(node) {
                    if (!node.id) {
                        log("Error: Node missing ID", 'error');
                        errors++;
                    } else {
                        if (allIds.has(node.id)) {
                            const existing = allIds.get(node.id);
                            log(`Error: Duplicate Node ID: ${node.id}`, 'error');
                            log(`  Existing: ${existing.type} '${existing.name}'`, 'error');
                            log(`  New: Node '${node.labels[0].text}'`, 'error');
                            errors++;
                        }
                        allIds.set(node.id, { type: 'Node', name: node.labels[0].text });
                    }

                    if (node.ports) {
                        node.ports.forEach(port => {
                            if (!port.id) {
                                log("Error: Port missing ID", 'error');
                                errors++;
                            } else {
                                if (allIds.has(port.id)) {
                                    const existing = allIds.get(port.id);
                                    log(`Error: Duplicate Port ID: ${port.id}`, 'error');
                                    log(`  Existing: ${existing.type} '${existing.name}'`, 'error');
                                    log(`  New: Port '${port.labels[0].text}'`, 'error');
                                    errors++;
                                }
                                allIds.set(port.id, { type: 'Port', name: port.labels[0].text });
                                portIds.add(port.id);
                            }
                        });
                    }

                    if (node.children) {
                        node.children.forEach(traverse);
                    }
                }

                traverse(rootNode);

                if (rootNode.edges) {
                    rootNode.edges.forEach(edge => {
                        if (!edge.id) {
                            log("Error: Edge missing ID", 'error');
                            errors++;
                        }
                        
                        if (edge.sources) {
                            edge.sources.forEach(src => {
                                if (!portIds.has(src)) {
                                    log(`Error: Edge ${edge.id} references non-existent source port: ${src}`, 'error');
                                    errors++;
                                }
                            });
                        } else {
                            log(`Error: Edge ${edge.id} missing sources`, 'error');
                            errors++;
                        }

                        if (edge.targets) {
                            edge.targets.forEach(tgt => {
                                if (!portIds.has(tgt)) {
                                    log(`Error: Edge ${edge.id} references non-existent target port: ${tgt}`, 'error');
                                    errors++;
                                }
                            });
                        } else {
                            log(`Error: Edge ${edge.id} missing targets`, 'error');
                            errors++;
                        }
                    });
                }

                if (errors > 0) {
                    log(`Validation failed with ${errors} errors. See log above.`, 'error');
                    return false;
                }
                log("Validation passed.");
                return true;
            }

            // --- Layout & Rendering ---
            function layoutAndRender(graphData) {
                if (!validateGraph(graphData)) {
                    alert("Graph validation failed. Check debug log.");
                    showLoading(false);
                    return;
                }

                showLoading(true, "Calculating Layout...");
                log("Starting ELK layout...");
                
                const elkOptions = {
                    'algorithm': 'layered',
                    'org.eclipse.elk.direction': 'RIGHT',
                    'org.eclipse.elk.spacing.nodeNode': '60',
                    'org.eclipse.elk.spacing.edgeNode': '30',
                    'org.eclipse.elk.edgeRouting': 'ORTHOGONAL',
                    'org.eclipse.elk.layered.spacing.edgeNodeBetweenLayers': '30',
                    'org.eclipse.elk.layered.nodePlacement.strategy': 'BRANDES_KOEPF',
                    'org.eclipse.elk.padding': '[top=50,left=50,bottom=50,right=50]'
                };

                elk.layout(graphData, { layoutOptions: elkOptions })
                    .then(graph => {
                        log("Layout successful!");
                        currentGraph = graph;
                        renderGraph(graph);
                        showLoading(false);
                        fitToScreen();
                    })
                    .catch(err => {
                        log("Layout Error: " + err.message, 'error');
                        console.error(err);
                        showLoading(false);
                        alert("Layout Error: " + err.message);
                    });
            }

            function renderGraph(graph) {
                log("Rendering graph...");
                zoomLayer.innerHTML = '';
                
                const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
                defs.innerHTML = `
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                    refX="10" refY="3.5" orient="auto">
                      <polygon points="0 0, 10 3.5, 0 7" fill="#adb5bd" />
                    </marker>
                    <marker id="arrowhead-active" markerWidth="10" markerHeight="7" 
                    refX="10" refY="3.5" orient="auto">
                      <polygon points="0 0, 10 3.5, 0 7" fill="#0d6efd" />
                    </marker>
                `;
                zoomLayer.appendChild(defs);

                let nodeCount = 0;
                let edgeCount = 0;

                function renderNode(node, parentGroup) {
                    nodeCount++;
                    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    g.setAttribute("transform", `translate(${node.x},${node.y})`);
                    g.classList.add("node-group");
                    
                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute("width", node.width);
                    rect.setAttribute("height", node.height);
                    rect.setAttribute("rx", 4);
                    rect.classList.add("node-rect");
                    
                    const userData = node.properties?.userData || {};
                    rect.setAttribute("fill", userData.background_color || "#ffffff");
                    rect.setAttribute("stroke", userData.color || "#333");
                    
                    rect.onclick = (e) => {
                        e.stopPropagation();
                        updateInfo(userData, 'Node');
                        highlight(g);
                    };
                    
                    g.appendChild(rect);

                    if (node.labels && node.labels.length > 0) {
                        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        text.setAttribute("x", node.width / 2);
                        text.setAttribute("y", 15);
                        text.textContent = node.labels[0].text;
                        text.classList.add("node-label");
                        g.appendChild(text);
                    }

                    if (node.ports) {
                        node.ports.forEach(port => {
                            const pg = document.createElementNS("http://www.w3.org/2000/svg", "g");
                            pg.setAttribute("transform", `translate(${port.x},${port.y})`);
                            
                            const prect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                            prect.setAttribute("width", port.width);
                            prect.setAttribute("height", port.height);
                            prect.classList.add("port-rect");
                            
                            const title = document.createElementNS("http://www.w3.org/2000/svg", "title");
                            title.textContent = port.properties?.userData?.name || "Port";
                            prect.appendChild(title);

                            pg.appendChild(prect);
                            g.appendChild(pg);
                        });
                    }

                    if (node.children) {
                        node.children.forEach(child => renderNode(child, g));
                    }

                    if (node.edges) {
                        node.edges.forEach(edge => {
                            edgeCount++;
                            if (!edge.sections) return;
                            
                            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                            let d = "";
                            edge.sections.forEach(section => {
                                d += `M ${section.startPoint.x} ${section.startPoint.y} `;
                                if (section.bendPoints) {
                                    section.bendPoints.forEach(bp => {
                                        d += `L ${bp.x} ${bp.y} `;
                                    });
                                }
                                d += `L ${section.endPoint.x} ${section.endPoint.y} `;
                            });
                            
                            path.setAttribute("d", d);
                            path.classList.add("edge-path");
                            path.setAttribute("marker-end", "url(#arrowhead)");
                            
                            const userData = edge.properties?.userData || {};
                            path.onclick = (e) => {
                                e.stopPropagation();
                                updateInfo(userData, 'Link');
                                document.querySelectorAll('.highlighted').forEach(el => el.classList.remove('highlighted'));
                                path.classList.add('highlighted');
                                path.setAttribute("marker-end", "url(#arrowhead-active)");
                            };

                            g.appendChild(path);
                        });
                    }

                    parentGroup.appendChild(g);
                }

                renderNode(graph, zoomLayer);
                log(`Rendered ${nodeCount} nodes and ${edgeCount} edges.`);
            }

            function highlight(element) {
                document.querySelectorAll('.highlighted').forEach(el => el.classList.remove('highlighted'));
                document.querySelectorAll('.edge-path').forEach(el => el.setAttribute("marker-end", "url(#arrowhead)"));
                element.classList.add('highlighted');
            }

            // --- Zoom/Pan ---
            function updateTransform() {
                zoomLayer.setAttribute("transform", `translate(${transform.x},${transform.y}) scale(${transform.k})`);
            }

            function fitToScreen() {
                if (!currentGraph) return;
                const bounds = zoomLayer.getBBox();
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                if (bounds.width === 0 || bounds.height === 0) {
                    log("Warning: Graph bounds are zero.", 'warn');
                    return;
                }

                const scale = Math.min(
                    (containerWidth - 40) / bounds.width,
                    (containerHeight - 40) / bounds.height
                );
                
                transform.k = Math.min(scale, 1);
                transform.x = (containerWidth - bounds.width * transform.k) / 2 - bounds.x * transform.k;
                transform.y = (containerHeight - bounds.height * transform.k) / 2 - bounds.y * transform.k;
                
                updateTransform();
            }

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomIntensity = 0.1;
                const delta = e.deltaY > 0 ? -zoomIntensity : zoomIntensity;
                const newScale = transform.k * (1 + delta);
                
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                transform.x -= (mouseX - transform.x) * delta;
                transform.y -= (mouseY - transform.y) * delta;
                transform.k = newScale;
                
                updateTransform();
            });

            container.addEventListener('mousedown', (e) => {
                isDragging = true;
                startPoint = { x: e.clientX - transform.x, y: e.clientY - transform.y };
            });

            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                e.preventDefault();
                transform.x = e.clientX - startPoint.x;
                transform.y = e.clientY - startPoint.y;
                updateTransform();
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // --- Initialization ---
            function loadMode(mode) {
                showLoading(true, "Loading Data...");
                log(`Loading mode: ${mode}`);
                
                const initData = () => {
                    if (window.architectureData && window.architectureData[mode]) {
                        try {
                            const elkGraph = transformDataToElk(window.architectureData[mode]);
                            layoutAndRender(elkGraph);
                        } catch(e) {
                            log("Error processing data: " + e.message, 'error');
                            console.error(e);
                            alert("Error processing data: " + e.message);
                            showLoading(false);
                        }
                    } else {
                        log("Failed to load data for mode: " + mode, 'error');
                        alert("Failed to load data for mode: " + mode);
                        showLoading(false);
                    }
                };

                if (window.architectureData && window.architectureData[mode]) {
                    initData();
                    return;
                }
                
                const script = document.createElement('script');
                script.src = `data/${mode}.js`;
                script.onload = initData;
                script.onerror = function(e) {
                    log("Error loading script for mode: " + mode, 'error');
                    showLoading(false);
                    alert("Error loading script for mode: " + mode);
                };
                document.body.appendChild(script);
            }

            loadMode(selector.value);
            
            selector.addEventListener('change', function(e) {
                loadMode(e.target.value);
            });
        });
    </script>
</body>
</html>
